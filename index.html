<!doctype html>
<html>

<head>
  <script src="https://pixijs.download/release/pixi.js"></script>
</head>

<body>
  <h1>Hello PixiJS</h1>
  Game ID: <input id="game-id" value="123"/>
  <button id="join-game-button">Join Game</button>
  <button id="create-game-button">Create Game</button>
  <div>
    Current Turn: <div id="current-turn-text"><div/>
  </div>
  <script type="module">
    import { atlasData } from './spritesheet.js';
    import { getValidMoves } from './pieceMove.js';

    const gameIdInput = document.getElementById("game-id");
    const joinGameButton = document.getElementById("join-game-button")
    const createGameButton = document.getElementById("create-game-button")

    // board size in px
    const boardSize = 128;
    const GAME_ID = gameIdInput.value;
    const BLACK_PLAYER = "black";
    const WHITE_PLAYER = "white";

    let gamestate;
    let player;

    joinGameButton.onclick = joinGame;
    createGameButton.onclick = createGame;

    async function createGame(event) {
      gameIdInput.style.visibility='hidden';
      joinGameButton.style.visibility='hidden';
      createGameButton.style.visibility='hidden';
      await fetch(`http://localhost:3000/api/create/${GAME_ID}`, { method: "POST" })
      .then(resp => resp.json())
      .then(newGameState => {
        console.log("Created newGameState", newGameState);
        gamestate = newGameState
        // Whoever creates the game is white
        player = WHITE_PLAYER;
        setBoard();
      })
      .catch(
        (error) => console.error("Error creating game", error)
      );
    }

    async function joinGame(event) {
      gameIdInput.style.visibility='hidden';
      joinGameButton.style.visibility='hidden';
      createGameButton.style.visibility='hidden';
      await fetch(`http://localhost:3000/api/join/${GAME_ID}`, { method: "POST" })
      .then(resp => resp.json())
      .then(newGameState => {
        console.log("Joined newGameState", newGameState);
        gamestate = newGameState
        // Whoever joins the game is black
        player = BLACK_PLAYER;
        setBoard();
      })
      .catch(
        (error) => console.error("Error joining game", error)
      );
    }

    // create app
    const app = new PIXI.Application();
    await app.init({ background: '#1099bb', resizeTo: window });
    document.body.appendChild(app.canvas);


    // create assets
    const sheetTexture = await PIXI.Assets.load('assets/spritesheet.png');
    const spritesheet = new PIXI.Spritesheet(
      sheetTexture,
      atlasData
    );
    await spritesheet.parse();


    // game setup
    let dragTarget = null;
    let clickTarget = null;
    let startPos = [];
    let validMoves = [];

    function addPiece(x, y, pieceType) {
      let piece = PIXI.Sprite.from(pieceType);
      piece.x = x * boardSize;
      piece.y = y * boardSize;

      piece.eventMode = "static";
      piece.cursor = "pointer";

      piece.on('pointerdown', onDragStart, piece);
      piece.on('pointerdown', onClick);
      //piece.on('pointerleave', offClick)

      app.stage.addChild(piece);
    }

    function pieceToNotation(piece) {
      if (piece === spritesheet.textures.pawn_black || piece === "pawn_black") {
        return "p";
      }
      if (piece === spritesheet.textures.knight_black || piece === "knight_black") {
        return "n";
      }
      if (piece === spritesheet.textures.bishop_black || piece === "bishop_black") {
        return "b";
      }
      if (piece === spritesheet.textures.rook_black || piece === "rook_black") {
        return "r";
      }
      if (piece === spritesheet.textures.queen_black || piece === "queen_black") {
        return "q";
      }
      if (piece === spritesheet.textures.king_black || piece === "king_black") {
        return "k";
      }
      if (piece === spritesheet.textures.pawn_white || piece === "pawn_white") {
        return "P";
      }
      if (piece === spritesheet.textures.knight_white || piece === "knight_white") {
        return "N";
      }
      if (piece === spritesheet.textures.bishop_white || piece === "bishop_white") {
        return "B";
      }
      if (piece === spritesheet.textures.rook_white || piece === "rook_white") {
        return "R";
      }
      if (piece === spritesheet.textures.queen_white || piece === "queen_white") {
        return "Q";
      }
      if (piece === spritesheet.textures.king_white || piece === "king_white") {
        return "K";
      }
    }

    function notationToPiece(piece) {
      if (piece === "p") {
        return spritesheet.textures.pawn_black;
      }
      if (piece === "n") {
        return spritesheet.textures.knight_black;
      }
      if (piece === "b") {
        return spritesheet.textures.bishop_black;
      }
      if (piece === "r") {
        return spritesheet.textures.rook_black;
      }
      if (piece === "q") {
        return spritesheet.textures.queen_black;
      }
      if (piece === "k") {
        return spritesheet.textures.king_black;
      }
      if (piece === "P") {
        return spritesheet.textures.pawn_white;
      }
      if (piece === "N") {
        return spritesheet.textures.knight_white;
      }
      if (piece === "B") {
        return spritesheet.textures.bishop_white;
      }
      if (piece === "R") {
        return spritesheet.textures.rook_white;
      }
      if (piece === "Q") {
        return spritesheet.textures.queen_white;
      }
      if (piece === "K") {
        return spritesheet.textures.king_white;
      }
    }

    function setBoard(){
      // Set board pieces before game pieces so that pieces show on top of board pieces
      let board = gamestate.board;
      for(var y = 0; y < board.length; y++) {
        for(var x = 0; x < board[y].length; x++) {
          if(board[x][y] === 1){
              addPiece(x, y, spritesheet.textures.board_piece)
            }
        }
      }

      for(var y = 0; y < board.length; y++) {
          for(var x = 0; x < board[y].length; x++) {
            if(board[x][y] !== 0 && board[x][y] !== 1) {
              addPiece(x, y, notationToPiece(board[x][y]))
            }
          }
      }
      updateCurrentTurn();
    }

    /**
     * Updates the current turn text to reflect the current gamestate.
     */
    function updateCurrentTurn() {
      console.log(document.getElementById("current-turn-text").innerText);
      document.getElementById("current-turn-text").innerText = gamestate.currentTurn;
    }

    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.on('pointerup', onDragEnd);
    app.stage.on('pointerupoutside', onDragEnd);

    let highlightContainer = new PIXI.Container;
    app.stage.addChild(highlightContainer);


    function clearHightlights() {
      if (highlightContainer.parent !== null) {
        highlightContainer.parent.removeChild(highlightContainer);
        highlightContainer = new PIXI.Container;
      }
    }
    // input functions
    function onClick() {
      validMoves = [];
      clearHightlights();

      clickTarget = this;
      let gridAlignedX = Math.floor(clickTarget.x / boardSize);
      let gridAlignedY = Math.floor(clickTarget.y / boardSize);

      if (clickTarget.texture.label !== "board_piece") {
        validMoves = getValidMoves(gridAlignedX, gridAlignedY, gamestate.board, clickTarget.texture.label);
      }

      validMoves.forEach((validMove) => {
        const rect = new PIXI.Graphics()
          .rect(0, 0, boardSize, boardSize)
          .fill({ color: 0xFFFF00, alpha: 0.5 })
          .on('pointerdown', onHighlightClick);
        rect.eventMode = "static";
        rect.cursor = "pointer";
        rect.x = validMove[0] * boardSize;
        rect.y = validMove[1] * boardSize;
        highlightContainer.addChild(rect);
      });
      app.stage.addChild(highlightContainer);
    }

    function onHighlightClick() {
      let gridAlignedX = Math.floor(clickTarget.x / boardSize);
      let gridAlignedY = Math.floor(clickTarget.y / boardSize);
      if(gamestate.currentTurn === player) {
        gamestate.board[gridAlignedX][gridAlignedY] = 1;
        clickTarget.x = this.x;
        clickTarget.y = this.y;
      }
      clearHightlights();
    }

    function onDragMove(event) {
      if (dragTarget && gamestate.currentTurn === player) {
        dragTarget.parent.toLocal(event.global, null, dragTarget.position);
      }
    }

    function onDragStart() {

      if(gamestate.currentTurn !== player) {
        return;
      }

      // Store a reference to the data
      startPos = [this.x, this.y];
      this.alpha = 0.5;
      dragTarget = this;
      app.stage.on('pointermove', onDragMove);

      // set board to be empty at that location
      let gridAlignedX = Math.floor(dragTarget.x / boardSize);
      let gridAlignedY = Math.floor(dragTarget.y / boardSize);
      if (dragTarget.texture.label !== "board_piece") {
        gamestate.board[gridAlignedX][gridAlignedY] = 1;
      } else {
        gamestate.board[gridAlignedX][gridAlignedY] = 0;
        gamestate.board[gridAlignedX + 1][gridAlignedY + 1] = 0;
        gamestate.board[gridAlignedX][gridAlignedY + 1] = 0;
        gamestate.board[gridAlignedX + 1][gridAlignedY] = 0;
      }
    }

    async function onDragEnd() {
      if (dragTarget && gamestate.currentTurn === player) {
        // snap to grid
        let gridAlignedX = Math.floor(dragTarget.x / boardSize);
        let gridAlignedY = Math.floor(dragTarget.y / boardSize);

        if (dragTarget.texture.label !== "board_piece") {
          var hash = {};
          for (var i = 0; i < validMoves.length; i += 1) {
            hash[validMoves[i]] = i;
          }
          if (hash.hasOwnProperty([gridAlignedX, gridAlignedY])) {
            dragTarget.x = boardSize * gridAlignedX;
            dragTarget.y = boardSize * gridAlignedY;

            // update board state
            gamestate.board[gridAlignedX][gridAlignedY] = pieceToNotation(dragTarget.texture.label);
            clearHightlights();
          } else {
            dragTarget.x = startPos[0];
            dragTarget.y = startPos[1];
          }
        } else {
          dragTarget.x = boardSize * gridAlignedX;
          dragTarget.y = boardSize * gridAlignedY;
          gamestate.board[gridAlignedX][gridAlignedY] = 1;
          gamestate.board[gridAlignedX + 1][gridAlignedY] = 1;
          gamestate.board[gridAlignedX][gridAlignedY + 1] = 1;
          gamestate.board[gridAlignedX + 1][gridAlignedY + 1] = 1;
        }

        if(dragTarget.x !== startPos[0] || dragTarget.y !== startPos[1]) {
          fetch(`http://localhost:3000/api/move/${GAME_ID}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(gamestate.board)
          })
          .then(response => response.json())
          .then(newGameState =>{
            gamestate = newGameState;
            updateCurrentTurn();
            setInterval(() => {
              fetch(`http://localhost:3000/api/game/${GAME_ID}`, {
                headers: {
                  "Content-Type": "application/json",
                }
              })
              .then(response => response.json())
              .then(newGameState =>{
                gamestate = newGameState;
                updateCurrentTurn();
              });
            }, 10000);
          })
          .catch(err=>{
            console.log("Error sending piece move:", err)
          });
        }

        console.log(gamestate);

        // finish drag
        app.stage.off('pointermove', onDragMove);
        dragTarget.alpha = 1;
        dragTarget = null;
      }
    }
  </script>
</body>

</html>